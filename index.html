<!doctype html>
<html>
    <head>
        <title>PacBike</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <!-- Bootstrap -->
        <link rel="stylesheet" href="bootstrap/css/bootstrap.min.css">
        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
          <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        <style>
            @font-face {
                font-family: PressStart2P;
                src: url('fonts/PressStart2P.ttf');
            }
             
            html, body{
                font-family: PressStart2P;
                font-size: 16px;
                background-color: black;
                color: yellow;
                text-align: center;
            }

            body {
                opacity:0;
                overflow: hidden;
            }

            .label {
                margin: .5em .5em .3em .3em;
                font-size:18px;
            }
        </style>
    </head>
    <body>
        <div id="other stuff" style="margin-bottom:5px;margin-top:5px;">
            Info:<div id="currentInfo" style="display:inline-block;">0</div>
            Score:<div id="currentScore" style="display:inline-block;">0</div>
            Hi:<div id="highScore" style="display:inline-block;">0</div>
            Date:<div id="currentDate" style="display:inline-block;"></div>
            Time:<div id="currentTime" style="display:inline-block;"></div>
            Ghosts:<div id="currentGhostNb" style="display:inline-block;">0</div>
        </div>

        <div id="playground" style="background:url('images/grid-qgis3.png');background-size:1898px 960px;">
    
            <div id ="splash">
                <a id="start">Start</a>
                <div id="loadbar" style="background: 000; height: 32px; overflow: visible;"><span id="loadtext" style="color: red"></span></div>
            </div>
   
        </div>

        <div id="connectHere" style="margin-bottom:5px;margin-top:15px;">
            <div style="margin-left:50px;margin-right:50px;width:250px;display:inline-block;vertical-align:top;">
                <span class="label label-success">Step 1</span>
                <br><p style="margin-top:15px;">Connect to Wifi network <b>PACBIKE</b></p>
            </div>
            <div style="margin-left:50px;width:450px;display:inline-block;">
                <div style="display:inline-block;width:270px;vertical-align:top;">
                    <span class="label label-success">Step 2</span>
                    <br><p style="margin-top:15px;">Read what the PacBike project is about:</p>
                </div>
                <div style="display:inline-block;width:105px;">
                    <img style="vertical-align:bottom;" src="images/qrcode-project.png" height="100px"/>
                </div>
            </div>
            <div style="margin-left:50px;width:450px;display:inline-block;">
                <div style="display:inline-block;width:270px;vertical-align:top;">
                    <span class="label label-success">Step 3</span>
                    <br><p style="margin-top:15px;">Control PacMan:</p>
                </div>
                <div style="display:inline-block;width:105px;">
                    <img style="vertical-align:bottom;" src="images/qrcode-gamepad.png" height="100px"/>
                </div>
            </div>
        </div>

        <script language="JavaScript" type="text/javascript" src="gamepad/assets/js/jquery-min.js"></script>
        <!-- Include all compiled plugins (below), or include individual files as needed -->
        <script src="bootstrap/js/bootstrap.min.js"></script>
        <script language="JavaScript" type="text/javascript" src="jquery.gamequery-0.7.1.js"></script>
        <script src="GSAP/src/minified/TweenMax.min.js"></script>
        <script src="GSAP/src/minified/jquery.gsap.min.js"></script>
        <script src="jquery-cookie/jquery.cookie.js"></script>
        <script src="http://localhost:8888/socket.io/socket.io.js"></script>
        <script>
            // Node running on Orion server
            //var socket = io.connect('http://103.29.64.40:443');
            var socket = io.connect('http://localhost:8888');
            var eventLock = false;
            var previousMove;
            socket.on('gamepad', function (data) {
                console.log(JSON.stringify(data));
                if(!player[0].player.lock && !player[0].player.dead){
                    if (data.go)
                    {
                        var posx = player[0].player.node.x();
                        var posy = player[0].player.node.y();
                        previousMove = data.go;
                        pacmanElt.setAnimation(pacman["walking"]);
                        //console.log('Received gamepad data, direction:'+data.go);
                        if(data.go == "right") {
                            //$.gameQuery.keyTracker[68] = true;
                            var nextpos = posx+SPEEDX;
                            player[0].player.lock = true;
                            player[0].player.moveTo(nextpos,posy);
                        } 
                        else if(data.go == "left") {
                            //$.gameQuery.keyTracker[65] = true;
                            var nextpos = posx-SPEEDX;
                            player[0].player.lock = true;
                            player[0].player.moveTo(nextpos,posy);
                        }
                        else if(data.go == "up") {
                            //$.gameQuery.keyTracker[87] = true;
                            var nextpos = posy-SPEEDY;
                            player[0].player.lock = true;
                            player[0].player.moveTo(posx,nextpos);
                        }
                        else if(data.go == "down") {
                            //$.gameQuery.keyTracker[83] = true;
                            var nextpos = posy+SPEEDY;
                            player[0].player.lock = true;
                            player[0].player.moveTo(posx,nextpos);
                        }
                    }
                }
                else
                {
                    if (data.go)
                    {
                        console.log('Rejected gamepad data because of lock'+JSON.stringify(data));
                    }
                }

                if(data.stop) {
                    previousMove = "stop";
                    pacmanElt.setAnimation(pacman["idle"]);
                }

            });

            socket.on('connect', function (data) {
                console.log("Client connected: "+data);
                //Managing a queue of players?
            });

            socket.on('disconnect', function (data) {
                //
                console.log("Client disconnected: "+data);
            });

            // So that it fits on a 1280 pixels display: tileW=17,tileH=22
            // Fit the projector: tileW=26,tileH=30
            var tileW = 26;
            // Height is less of a constraint at this stage
            var tileH = 30;
            var ghostRoutes, ghostRoutesLength, lastGhostIdx=0, ghostAnimArr;
            var GHOST_OPACITY_TRANSITION_MS = 1000;

            var REFRESH_RATE = 30;
            // Number of minutes a refresh is representing (timer increment)
            var SIMULATED_TIME_RATE = 0.5;
            // Initial timer value
            var timer = 0;

            var playerHit = false;
            var playerW = 26;
            var playerH = 28;
            var player,allGhosts=new Array();
            var SPEEDX = tileW;
            var SPEEDY = tileH;
            // Duration (in ms) to get to the next tile
            // for the player
            var STEP_SPEEDX = 300;
            var STEP_SPEEDY = 300;
            // for the ghosts
            var GHOST_STEP_SPEEDX = 200;
            var GHOST_STEP_SPEEDY = 200;

            // Generated with gQ's Tiles map editor
            // http://gamequeryjs.com/tools/tilemapeditor/

            var animations = [];
            // Placeholder: not used but still needed in the animation array
            animations[0] =  new $.gameQuery.Animation({
                imageURL:     'images/none.png'
            });
            // Buildings
            animations[1] =  new $.gameQuery.Animation({
                imageURL:      'images/none.png'
            });
            // Main arteries
            animations[2] =  new $.gameQuery.Animation({
                imageURL:      'http://placehold.it/'+tileW+'x'+tileH+'/000000&text=.'
            });
            // Bike stations
            animations[3] =  new $.gameQuery.Animation({
                imageURL:      'images/cycling_sign-small.png'
            });
            // CBD entry points
            animations[4] =  new $.gameQuery.Animation({
                imageURL:      'http://placehold.it/'+tileW+'x'+tileH+'/0B173B&text=.'
            });

            // Street names - individual characters
            for (var k=65;k<=90;k++)
            {
                animations[k-60] =  new $.gameQuery.Animation({
                    imageURL:      'http://placehold.it/'+tileW+'x'+tileH+'/000000&text='+String.fromCharCode(k)
                });                
            }

            // Street names - horizontal
            // F L I N D E R S => 70 76 73 78 68 69 82 83
            // F L I N D E R S => 11 17 14 19 9 10 23 24
            // S T R E E T => 83 84 82 69 69 84
            // S T R E E T => 24 25 23 10 10 25
            // L A N E => 76 65 78 69
            // L A N E => 17 6 19 10
            // C O L L I N S => 67 79 76 76 73 78 83
            // C O L L I N S => 8 20 17 17 14 19 24
            // L I T T L E => 76 73 84 84 76 69
            // L I T T L E => 17 14 25 25 17 10
            // B O U R K E => 66 79 85 82 75 69
            // B O U R K E => 7 20 26 23 16 10
            // L O N S D A L E => 76 79 78 83 68 65 76 69
            // L O N S D A L E => 17 20 19 24 9 6 17 10
            // L A T R O B E => 76 65 84 82 79 66 69
            // L A T R O B E => 17 6 25 23 20 7 10

            // Street names - vertical
            // S P R I N G => 83 80 82 73 78 71
            // S P R I N G => 24 21 23 14 19 12
            // E X H I B I T I O N => 69 88 72 73 66 73 84 73 79 78
            // E X H I B I T I O N => 10 29 13 14 7 14 25 14 20 19
            // R U S S E L L => 82 85 83 83 69 76 76
            // R U S S E L L => 23 26 24 24 10 17 17
            // S W A N S T O N => 83 87 65 78 83 84 79 78
            // S W A N S T O N => 24 28 6 19 24 25 20 19
            // E L I Z A B E T H => 69 76 73 90 65 66 69 84 72
            // E L I Z A B E T H => 10 17 14 31 6 7 10 25 13
            // Q U E E N => 81 85 69 69 78
            // Q U E E N => 22 26 10 10 19
            // W I L L I A M S => 87 73 76 76 73 65 77 83
            // W I L L I A M S => 28 14 17 17 14 6 18 24
            // K I N G => 75 73 78 71
            // K I N G => 16 14 19 12
            // S P E N C E R => 83 80 69 78 67 69 82
            // S P E N C E R => 24 21 10 19 8 10 23

             // the tilemap array
            var map = [
                        [2,5,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,5 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,5,2,2,2],
                        [5,3,17,6 ,3 ,25,23,20,7 ,10,3 ,24,25,23,10,10,25,3 ,3 ,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2],
                        [2,3,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,24,2,2,2,2,2,2,2,2,23,2,2,2,2,2,2,2,2,10,2,2,2,2,2,2,3,24,2],
                        [2,3,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,28,2,2,2,2,2,2,2,2,26,2,2,2,2,2,2,2,2,29,2,2,2,2,2,2,2,21,5],
                        [2,3,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,4,2,2,2,2,2,2,2,6,2,2,2,2,2,2,2,2,24,2,2,2,2,2,2,2,2,13,2,2,2,2,2,2,2,23,2],
                        [2,3,17,14,25,25,17,10,3 ,3 ,3 ,17,20,19,24,9 ,6 ,17,10,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,19,3,3,3,3,3,3,3,3,24,3,3,3,3,3,3,3,3,14,3,3,3,3,3,3,3,14,2],
                        [2,3,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,24,4,2,2,2,2,2,2,2,10,2,2,2,2,2,2,2,2,7 ,2,2,2,2,2,2,2,19,2],
                        [2,3,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,25,2,2,2,2,2,2,2,2,17,2,2,2,2,2,2,2,2,14,2,2,2,2,2,2,2,12,2],
                        [2,3,17,20,19,24,9 ,6 ,17,10,3 ,24,25,23,10,10,25,3 ,3 ,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,20,3,3,3,3,3,3,3,3,17,3,3,3,3,3,3,3,3,25,3,3,3,3,3,3,3,3,5],
                        [2,3,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,19,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,14,2,2,2,2,2,2,2,3,2],
                        [2,3,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,2 ,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,20,2,2,2,2,2,2,2,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,19,2,2,2,2,2,2,2,3,2],
                        [2,3,17,14,25,25,17,10,3,3,3,7,20,26,23,16,10,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,3,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,5],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,3,2,2,3,2,2,2,2,2,2,2,2,3,4,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,4,3,2,2,2,2,2,2,2,3,2],
                        [2,3,7,20,26,23,16,10,3,3,3,24,25,23,10,10,25,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,4,3,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,4,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,3,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,3,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,17,14,25,25,17,10,3,3,3,8,20,17,17,14,19,24,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [2,3,2,2,2,2,2,2,2,4,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,10,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,5],
                        [5,3 ,3,3,3,3,3,3,3,3,3 ,3,3,3,3,3,3,3,3,28,3,3,3,3,3,3,3,3 ,3,3,3,3,3,3,3,3,17,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,8,20,17,17,14,19,24,3,3,24,25,23,10,10,25,3,3,2],
                        [2,24,2,2,2,2,2,2,2,2,3 ,2,2,2,2,2,2,2,2,14,2,2,4,3,2,2,2,3 ,2,2,2,2,2,2,2,2,14,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,4,3,2],
                        [2,21,2,2,2,2,2,2,2,2,3 ,2,2,2,2,2,2,2,2,17,2,2,2,3,2,2,2,3 ,2,2,2,2,2,2,2,2,31,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [2,10,2,2,2,2,2,2,2,2,3 ,2,2,2,2,2,2,2,2,17,2,2,2,3,2,2,2,22,2,2,2,2,2,2,2,2,6 ,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [2,19,3,3,3,3,3,3,3,3,16,3,3,3,3,3,3,3,3,14,3,3,3,3,3,3,3,26,3,3,3,3,3,3,3,3,7 ,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,11,17,14,19,9,10,23,24,3,17,6,19,10,3,3,3,3,2],
                        [2, 8,2,2,2,2,2,2,2,2,14,2,2,2,2,2,2,2,2,6 ,2,2,2,3,2,2,2,10,2,2,2,2,2,2,2,2,10,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [2,10,2,2,2,2,2,2,2,2,19,2,2,2,2,2,2,2,2,18,2,2,2,3,2,2,2,10,2,2,2,2,2,2,2,2,25,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [2,23,2,2,2,2,2,2,2,2,12,2,2,2,2,2,2,2,2,24,2,2,2,3,2,2,2,19,2,2,2,2,2,2,2,2,13,2,2,2,2,2,2,2,2,3,4,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,3,2],
                        [5, 3,3,3,3,3,3,3,3,3,3 ,3,3,3,3,3,3,3,3,3 ,3,3,3,3,3,3,3,3 ,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,11,17,14,19,9,10,23,24,3,24,25,23,10,10,25,3,3,5],
                        [2, 5,2,2,2,2,2,2,2,2,5 ,2,2,2,2,2,2,2,2,5 ,2,2,2,2,5,2,2,2 ,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,2,2,2,2,5,2,2,2,2]
                    ];

            // Calculating board size based on the tilemap
            var tileNbX = map[0].length;
            var tileNbY = map.length;
            var PLAYGROUND_WIDTH    = tileNbX * tileW;
            var PLAYGROUND_HEIGHT   = tileNbY * tileH;


            var pacman=[];
            // Let the game begin!
            pacman["idle"] = new $.gameQuery.Animation({
                imageURL: "images/pm-idle.png"
            });

            pacman["walking"] = new $.gameQuery.Animation({
                imageURL: "images/pm-down.png",
                numberOfFrame: 9,
                delta: 27,
                rate: 50,
                type: $.gameQuery.ANIMATION_HORIZONTAL
            });

            pacman["hit"] = new $.gameQuery.Animation({
                imageURL: "images/pm-hit.png",
                numberOfFrame: 7,
                delta: 26,
                rate: 200,
                type: $.gameQuery.ANIMATION_HORIZONTAL | $.gameQuery.ANIMATION_ONCE
            });

            // My own wall collision detection function
            var collisionDetect = function(x,y,animationCode){
                var cellx = Math.round(((x+PLAYGROUND_WIDTH/2)*tileNbX)/PLAYGROUND_WIDTH)-1;
                var celly = Math.round(((y+PLAYGROUND_HEIGHT/2)*tileNbY)/PLAYGROUND_HEIGHT);
                // Mapping x and y to a map tile
                console.log("Collision detection with ("+cellx+","+celly+"):"+(map[celly][cellx] == animationCode));
                return map[celly][cellx] == animationCode;
            };

            //
            var plotXFromTile = function(colX){
                var pixel_x = (parseInt(colX)+1)*tileW;
                return pixel_x;
            }

            var plotYFromTile = function(rowY){
                var pixel_y = (parseInt(rowY)+1)*tileH+2;
                return pixel_y;
            }

            // Pointers to current date / time markers
            var currentDateDisplay = $('#currentDate');
            currentDateDisplay.html("...");
            var currentTimeDisplay = $('#currentTime');
            currentTimeDisplay.html("...");
            var currentInfoDisplay = $('#currentInfo');

            if ($.cookie('hiscore'))
            {
                $('#highScore').html($.cookie('hiscore'));                
            }
            else
            {
                $.cookie('hiscore',0);
            }

            $(window).on('resize',function(){
                currentInfoDisplay.html($(window).width()+"X"+$(window).height());
            });
            $(window).resize();

            var dt;
            var displayTime = function(offsetInMn){
                if (!dt)
                {
                    var fts = ghostRoutes[0].s;
                    dt = new Date(fts.substring(0,4),fts.substring(5,7),fts.substring(8,10),fts.substring(11,13),fts.substring(14,16),fts.substring(17,19));
                }
                // Applying the offset (needs to be an integer - should we cater for decimal minutes i.e. seconds? yes)
                if (offsetInMn % 1 !== 0)
                {
                    offsetInS = parseInt(Math.round(offsetInMn*60));
                    dt.setSeconds(dt.getSeconds()+offsetInS);
                }
                else
                {
                    dt.setMinutes(dt.getMinutes()+offsetInMn);
                }

                // Displaying it
                var minutesStr = dt.getMinutes();
                if (minutesStr<10){minutesStr = "0"+minutesStr;}
                var hoursStr = dt.getHours();
                if (hoursStr<10){hoursStr = "0"+hoursStr;}

                currentDateDisplay.html(dt.getDate()+"/"+parseInt(dt.getMonth()+0)+"/"+dt.getFullYear());
                currentTimeDisplay.html(hoursStr+":"+minutesStr);
            }

            var currentGhostNb = 0;
            var currentGhostNbDisplay = $('#currentGhostNb');            
            var displayGhostsInPlay = function(nb){
                currentGhostNb += nb; 
                currentGhostNbDisplay.html(currentGhostNb); 
            }

            // Configuring the playground
            $('#playground').playground({
                    height: PLAYGROUND_HEIGHT, 
                    width: PLAYGROUND_WIDTH, 
                    keyTracker: true
                })
                .addTilemap("tilemap", map,  animations, {
                    width: tileW, 
                    height: tileH, 
                    sizex: tileNbX, 
                    sizey: tileNbY
                }).end()
                .addGroup("bikestations", {
                    width: PLAYGROUND_WIDTH, 
                    height: PLAYGROUND_HEIGHT
                }).end()
                .addGroup("pacgums", {
                    width: PLAYGROUND_WIDTH, 
                    height: PLAYGROUND_HEIGHT
                }).end()
                .addGroup("player",{
                    width: playerW, 
                    height: playerH
                }).end()
                .addGroup("ghosts",{
                    width: playerW, 
                    height: playerH
                }).end()
                // Centering the playground
                .css({"position":"relative","margin":"0 auto"})
                ;

            
            // configure the loading bar
            /*
            $.loadCallback(function(percent){
                $("#loadBar").width(400*percent);
                $("#loadtext").html(""+percent+"%")
            });
            */

            function spawnFruit() {
                // Positionning the pacgums
                var pacgumArr = {
                    "apple": {
                        "animation":new $.gameQuery.Animation({imageURL: "images/apple-small.png"}),
                        "width": 20,
                        "height": 20,
                        "pts": 10
                    },
                    "banana": {
                        "animation":new $.gameQuery.Animation({imageURL: "images/banana-small.png"}),
                        "width": 25,
                        "height": 16,
                        "pts": 20
                    },
                    "cherry": {
                        "animation":new $.gameQuery.Animation({imageURL: "images/cherry-small.png"}),
                        "width": 22,
                        "height": 22,
                        "pts": 30
                    },
                    "coffee": {
                        "animation":new $.gameQuery.Animation({imageURL: "images/coffeecup-small.png"}),
                        "width": 25,
                        "height": 24,
                        "pts": 100
                    },
                    "strawberry": {
                        "animation":new $.gameQuery.Animation({imageURL: "images/strawberry-small.png"}),
                        "width": 16,
                        "height": 24,
                        "pts": 40
                    },
                    "watermelon": {
                        "animation":new $.gameQuery.Animation({imageURL: "images/watermelon-small.png"}),
                        "width": 26,
                        "height": 21,
                        "pts": 50
                    }
                };

                var pacgum;

                for (var j=0; j < tileNbY ; j+=1)
                {
                    for (var i=0; i < tileNbX ; i+=1)
                    {
                        if ((map[j][i] == 3) && ((i+j)%8==0))
                        {
                            var r = Math.random();
                            if (r<0.5)
                            {
                                pacgum = pacgumArr["cherry"];
                            }
                            else if (r<0.7)
                            {
                                pacgum = pacgumArr["strawberry"];
                            }
                            else if (r<0.8)
                            {
                                pacgum = pacgumArr["banana"];
                            }
                            else if (r<0.9)
                            {
                                pacgum = pacgumArr["watermelon"];
                            }
                            else if (r<=1.0)
                            {
                                pacgum = pacgumArr["coffee"];
                            }

                            // Width and height must be those of the image
                            // Pox and posy must reflect the image size as well
                            $("#pacgums").addSprite("pg-"+i+"_"+j+"X"+pacgum.pts, {
                                animation: pacgum.animation,
                                posx: (i+1/2)*tileW-pacgum.width/2, 
                                posy: (j+1/2)*tileH-pacgum.height/2,
                                width: pacgum.width,
                                height: pacgum.height
                            });

                        }
                    }
                }
            }

            // register the start button and remove the splash screen once the game is ready to starts
            $("#start").click(function(){
                // Game initialisation routine
                var gameInit = function(){
                    $("#splash").remove();

                    // Display the time
                    var firstOffsetMn = parseInt(ghostRoutes[0].o);
                    displayTime(-firstOffsetMn);

                    $("#player").addSprite("pacman", {
                        animation: pacman["idle"],
                        posx: 0,
                        posy: 0,
                        width: playerW, 
                        height: playerH
                    });

                    pacmanElt = $("#pacman");

                    ghostAnimArr = {
                        "green": new $.gameQuery.Animation({imageURL: "images/ghost-small-green.png"}),
                        "orange": new $.gameQuery.Animation({imageURL: "images/ghost-small-orange.png"}),
                        "red": new $.gameQuery.Animation({imageURL: "images/ghost-small-red.png"})
                    };

                    spawnFruit();

                    $("#player")[0].player = new Player($("#player"));
                    player = $("#player");

                    // Assigning a collision class to all tiles that can be walked on:
                    // Walls
                    $('.gQ_tileType_1').addClass("obstacle");
                    // CBD entry points/exits
                    $('.gQ_tileType_3').addClass("obstacle");
                    // Bike stations
                    $('.gQ_tileType_4').addClass("obstacle");

                };
                
                var releaseGhosts = function(currentTimer){
                    // Restart the board last ghost released + 1 hour
                    if (parseInt(ghostRoutes[ghostRoutesLength-1].o) < currentTimer+60)
                    {
                        // We've reached the end of the timer (+ 1 hour)
                        // We restart the board/game
                        $('body').fadeTo(1000,0,function(){
                            window.location="http://localhost:8080/pacbike";
                        });
                    }

                    if (currentTimer >= 5 && currentTimer < 6)
                    {
                        $('body').fadeTo(1000,1);
                    }

                    // Releasing the ghosts
                    for (var j=lastGhostIdx;j<ghostRoutesLength;j++)
                    {
                        if (parseInt(ghostRoutes[j].o) < currentTimer)
                        {
                            // Duration of trips: short / medium / long
                            var tripDuration = parseInt(ghostRoutes[j].d);

                            if (tripDuration < 20)
                            {ghost = ghostAnimArr["green"];}
                            else if (tripDuration < 40)
                            {ghost = ghostAnimArr["orange"];}
                            else
                            {ghost = ghostAnimArr["red"];}

                            // Release the ghost!
                            $("#ghosts").addSprite("ghost"+j, {
                                animation: ghost,
                                posx: 0, 
                                posy: 0,
                                width: playerW, 
                                height: playerH
                            });

                            $("#ghost"+j)[0].ghost = new Ghost($("#ghost"+j),ghostRoutes[j+""].l.split(","));
                            allGhosts[j] = $("#ghost"+j)[0].ghost;

                            // Incrementing the last released ghist index
                            lastGhostIdx++;
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                // Loading the asset file where the ghosts routes are
                $.getJSON("routed_events/assets.json",
                    {},
                    function(json){
                        //
                        if (json)
                        {
                            // Now moving to the detail page with this task id
                            console.log('Asset JSON file loaded: ' + Object.keys(json).length + ' events.');
                            // Global variable holding the routes
                            ghostRoutes = json;
                            ghostRoutesLength = Object.keys(ghostRoutes).length;
                            // Game init routine
                            $.playground().startGame(gameInit);
                        }
                    }
                );

                function Player(node){
                    var that = this;
                    this.node = node;
                    this.respawnTime = -1;
                    this.grace = false;
                    this.score = 0;
                    this.lock = false;
                    this.dead = false;

                    // Initial position - somewhere in the middle of the grid
                    this.node.x(PLAYGROUND_WIDTH/2-(PLAYGROUND_WIDTH/2%tileW)+tileW/2-playerW/2);
                    this.node.y(PLAYGROUND_HEIGHT/2-(PLAYGROUND_HEIGHT/2%tileH)-tileH/2-playerH/2);

                    this.addPoints=function(pts){
                        this.score += pts;
                        $('#currentScore').html(this.score);
                        if ($.cookie('hiscore') < this.score)
                        {
                            $.cookie('hiscore',this.score);
                            $('#highScore').html(this.score);
                        }
                    };

                    this.resetScore=function(pts){
                        // Should we be saving hi-scores in there?
                        this.score = 0;
                        $('#currentScore').html(this.score);
                    };                    

                    this.hit = function(){
                        //
                        this.resetScore();
                        this.dead = true;
                        pacmanElt.setAnimation(pacman["hit"]);
                        previousMove = "stop";
                        setTimeout(function(){
                            pacmanElt.setAnimation(pacman["idle"]);
                            that.dead = false;
                            that.lock = false;
                        }, 2500);
                    }

                    this.moveTo = function(newx,newy){
                        console.log('Moving from:'+this.node.x()+','+this.node.y()+' to '+newx+','+newy);

                        if(newx > 0 && newx <= PLAYGROUND_WIDTH && newx != this.node.x()){
                            if (!player.collision('#tilemap,#tilemap div.obstacle',{x:newx}).length)
                            {
                                //console.log('Moving to tile:'+$('#player').collision('#tilemap,#tilemap div.gQ_tileType_2',{x:newx})[0].id+' ('+$('#player').collision('#tilemap,#tilemap div',{x:newx}).length+' tiles detected)');

                                this.lock = true;
                                this.node.animate({x:newx}, 
                                    {
                                        duration:STEP_SPEEDX, 
                                        complete:function(){
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.x(newx);
                                        }
                                    }
                                );
                            }
                            else
                            {
                                player[0].player.lock = false;
                                //console.log('Can\'t move right/left due to tile:'+$('#pacman').collision('#tilemap,#tilemap div.gQ_tileType_1',{x:newx})[0].id);
                            }
                        }
                        else if (newy > 0 && newy <= PLAYGROUND_HEIGHT && newy != this.node.y()){
                            if (!player.collision('#tilemap,#tilemap div.obstacle',{y:newy}).length)
                            {
                                //console.log('Moving to tile:'+$('#player').collision('#tilemap,#tilemap div.gQ_tileType_2',{y:newy})[0].id+' ('+$('#player').collision('#tilemap,#tilemap div',{y:newy}).length+' tiles detected)');

                                this.lock = true;
                                this.node.animate({y:newy}, 
                                    {
                                        duration:STEP_SPEEDY, 
                                        complete:function(){
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.y(newy);
                                        }
                                    }
                                );
                            }
                            else
                            {
                                player[0].player.lock = false;
                                //console.log('Can\'t move up/down due to tile:'+$('#player').collision('#tilemap,#tilemap div.gQ_tileType_1',{y:newy})[0].id);
                            }
                        }
                        else
                        {
                            player[0].player.lock = false;
                        }
                    }

                    return true;
                }

                function Ghost(node,route,duration){
                    var that = this;
                    this.node = node;
                    this.route = route;
                    this.lock = false;

                    // Initial position
                    this.node.css("opacity",0);
                    this.node.x(plotXFromTile(parseInt(this.route[0].split("X")[0])));
                    this.node.y(plotYFromTile(parseInt(this.route[0].split("X")[1])));
                    this.node.animate({opacity:1},GHOST_OPACITY_TRANSITION_MS,function(){
                        displayGhostsInPlay(1);
                    });
                    // Removing the position we just consumed
                    this.route.shift();

                    // updates the position of the enemy
                    this.updateOne = function(playerNode){
                        if (this.route.length && !this.lock)
                        {
                            this.lock = true;
                            this.updateX(playerNode);
                            this.updateY(playerNode);
                        }

                        // If we arrived at the end of the route, we need to destroy the ghost and remove it from the ghost array
                        if (!this.route.length)
                        {
                            // The animation does not portray where the ghost really disappears
                            this.node.animate({opacity:0},GHOST_OPACITY_TRANSITION_MS,function(){
                                // We wanted to get this counter before the animation callback but that just won't work
                                displayGhostsInPlay(-1);

                                var ghostIdx = allGhosts.indexOf(that);
                                if (ghostIdx>-1)
                                {
                                    allGhosts.splice(ghostIdx,1);
                                }

                                // Removing the sprite from the DOM / gQ group
                                that.node.remove();
                            });
                        }
                    };    
                      
                    this.updateX = function(playerNode){
                        var nextposx = plotXFromTile(parseInt(this.route[0].split("X")[0]));
                        if (nextposx != this.node.x())
                        {
                            this.node.animate({x:nextposx}, 
                                {
                                    duration:GHOST_STEP_SPEEDX+(Math.random()*0.5-0.25)*GHOST_STEP_SPEEDX, 
                                    complete:function(){
                                        if (that.lock)
                                        {
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.x(nextposx);
                                            // Removing the position that's just been the object of the update
                                            that.route.shift();                                            
                                        }
                                    }
                                }
                            );
                        }
                    };
                    this.updateY= function(playerNode){
                        var nextposy = plotYFromTile(parseInt(this.route[0].split("X")[1]));
                        if (nextposy != this.node.y())
                        {
                            this.node.animate({y:nextposy}, 
                                {
                                    duration:GHOST_STEP_SPEEDY+(Math.random()*0.5-0.25)*GHOST_STEP_SPEEDY, 
                                    complete:function(){
                                        if (that.lock)
                                        {
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.y(nextposy);                                        
                                            // Removing the position that's just been the object of the update
                                            that.route.shift();                                            
                                        }
                                    }
                                }
                            );
                        }
                    };

                    return true;
                }

                $.playground().registerCallback(function(){
                    timer += SIMULATED_TIME_RATE;
                    releaseGhosts(timer);
                    displayTime(SIMULATED_TIME_RATE);

                    if (!player[0].player.dead)
                    {

                        var pacgumCollision = player.collision("#pacgums,#pacgums div");
                        if (pacgumCollision.length)
                        {
                            pacgumCollision.each(function(idx,pacgum){
                                //console.log("Collided with pacgum"+pacgum.id);
                                $('#'+pacgum.id).animate({opacity:0},100);
                                $('#'+pacgum.id).remove();

                                var ptsToAdd = parseInt(pacgum.id.split("X")[1]);
                                // Updating the score as well
                                player[0].player.addPoints(ptsToAdd);

                                // Checking if the board still has fruit
                                if ($('#pacgums')[0].children.length == 0)
                                {
                                    // Re-spawn fruit
                                    spawnFruit();
                                }
                            });
                        }

                        var ghostCollision = player.collision("#ghosts,#ghosts div");
                        if (ghostCollision.length)
                        {
                            ghostCollision.each(function(idx,ghost){
                                console.log("Ghost "+ghost.id+" has collided with Pacman!")
                                player[0].player.hit();
                            });
                        }

                        // Continuing to walk if move hasn't been stopped
                        if (previousMove != "stop")
                        {
                            //Update the movement of the player
                            if(!player[0].player.lock){
                                var posx = player[0].player.node.x();
                                var posy = player[0].player.node.y();
                                //$("#player")[0].player.update();
                                if(previousMove=="left"){ //this is left! (a)
                                    var nextpos = posx-SPEEDX;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(nextpos,posy);
                                }
                                if(previousMove=="right"){ //this is right! (d)
                                    var nextpos = posx+SPEEDX;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(nextpos,posy);
                                }
                                if(previousMove=="up"){ //this is up! (w)
                                    var nextpos = posy-SPEEDY;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(posx,nextpos);
                                }
                                if(previousMove=="down"){ //this is down! (s)
                                    var nextpos = posy+SPEEDY;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(posx,nextpos);
                                }
                            }
                        }

                    }


                    // Move the ghost
                    for (var j=0;j<allGhosts.length;j++)
                    {
                        if (allGhosts[j])
                        {
                            allGhosts[j].updateOne();
                        } 
                    }

                    }, REFRESH_RATE);
            });

            $("#start").click();

        </script>
    </body>
</html>
