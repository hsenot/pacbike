<!doctype html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>PacBike</title>
        <style>
        </style>
    </head>
    <body>
        <div id="other stuff">
            Score:
            <div id="currentScore" style="display:inline-block;">
            </div>
            Date:
            <div id="currentDate" style="display:inline-block;">
            </div>
            Time:            
            <div id="currentTime" style="display:inline-block;">
            </div>
            Ghosts:            
            <div id="currentGhostNb" style="display:inline-block;">
            </div>
        </div>

        <div id="playground">
            <div id ="splash">
                <a id="start">Start</a>
                <div id="loadbar" style="background: 000; height: 32px; overflow: visible;"><span id="loadtext" style="color: red"></span></div>
            </div>
        </div>

        <input id="keyEvt" type="text" style="display:hidden;">

        <script language="JavaScript" type="text/javascript" src="gamepad/assets/js/jquery-min.js"></script>
        <script language="JavaScript" type="text/javascript" src="jquery.gamequery-0.7.1.js"></script>
        <script src="GSAP/src/minified/TweenMax.min.js"></script>
        <script src="GSAP/src/minified/jquery.gsap.min.js"></script>
        <script src="http://localhost:8888/socket.io/socket.io.js"></script>
        <script>
            // Node running on Orion server
            //var socket = io.connect('http://103.29.64.40:443');
            var socket = io.connect('http://localhost:8888');
            var eventLock = false;
            var previousMove;
            socket.on('gamepad', function (data) {
                console.log(JSON.stringify(data));
                if(!player[0].player.lock && !player[0].player.dead){
                    if (data.go)
                    {
                        var posx = player[0].player.node.x();
                        var posy = player[0].player.node.y();
                        previousMove = data.go;
                        pacmanElt.setAnimation(pacman["walking"]);
                        //console.log('Received gamepad data, direction:'+data.go);
                        if(data.go == "right") {
                            //$.gameQuery.keyTracker[68] = true;
                            var nextpos = posx+SPEEDX;
                            player[0].player.lock = true;
                            player[0].player.moveTo(nextpos,posy);
                        } 
                        else if(data.go == "left") {
                            //$.gameQuery.keyTracker[65] = true;
                            var nextpos = posx-SPEEDX;
                            player[0].player.lock = true;
                            player[0].player.moveTo(nextpos,posy);
                        }
                        else if(data.go == "up") {
                            //$.gameQuery.keyTracker[87] = true;
                            var nextpos = posy-SPEEDY;
                            player[0].player.lock = true;
                            player[0].player.moveTo(posx,nextpos);
                        }
                        else if(data.go == "down") {
                            //$.gameQuery.keyTracker[83] = true;
                            var nextpos = posy+SPEEDY;
                            player[0].player.lock = true;
                            player[0].player.moveTo(posx,nextpos);
                        }
                    }
                }
                else
                {
                    if (data.go)
                    {
                        console.log('Rejected gamepad data because of lock'+JSON.stringify(data));
                    }
                }

                if(data.stop) {
                    previousMove = "stop";
                    pacmanElt.setAnimation(pacman["idle"]);
                    //console.log('Halting: '+data.stop);
                }

            });

            socket.on('connect', function (data) {
                //console.log(data);
                //Managing a queue of players?
            });

            // So that it fits on a 1280 pixels display: tileW=17,tileH=22
            // Fit the projector: tileW=26,tileH=30
            var tileW = 26;
            // Height is less of a constraint at this stage
            var tileH = 30;
            var ghostRoutes, lastGhostIdx=0, ghostAnimArr;
            var GHOST_OPACITY_TRANSITION_MS = 1000;

            var REFRESH_RATE = 30;
            // Number of minutes a refresh is representing (timer increment)
            var SIMULATED_TIME_RATE = 1;
            // Initial timer value
            var timer = 0;

            var playerHit = false;
            var playerW = 26;
            var playerH = 28;
            var player,allGhosts=new Array();
            var SPEEDX = tileW;
            var SPEEDY = tileH;
            // Duration (in ms) to get to the next tile
            // for the player
            var STEP_SPEEDX = 300;
            var STEP_SPEEDY = 300;
            // for the ghosts
            var GHOST_STEP_SPEEDX = 200;
            var GHOST_STEP_SPEEDY = 200;

            // Generated with gQ's Tiles map editor
            // http://gamequeryjs.com/tools/tilemapeditor/

            var animations = [];
            // Laneways
            animations[0] =  new $.gameQuery.Animation({
                imageURL:'http://placehold.it/'+tileW+'x'+tileH+'/0B173B&text=.'
            });
            // Buildings
            animations[1] =  new $.gameQuery.Animation({
                imageURL:      'http://placehold.it/'+tileW+'x'+tileH+'/0000FF&text=.'
            });
            // Main arteries
            animations[2] =  new $.gameQuery.Animation({
                imageURL:      'http://placehold.it/'+tileW+'x'+tileH+'/000000&text=.'
            });
            // Bike stations
            animations[3] =  new $.gameQuery.Animation({
                imageURL:      'http://placehold.it/'+tileW+'x'+tileH+'/F7FE2E&text=.'
            });
            // CBD entry points
            animations[4] =  new $.gameQuery.Animation({
                imageURL:      'http://placehold.it/'+tileW+'x'+tileH+'/0B173B&text=.'
            });

             // the tilemap array
            var map = [
                        [2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,5,2,2,2],
                        [5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2],
                        [2,3,2,1,2,2,2,1,2,2,3,1,2,1,2,2,2,2,2,3,1,1,1,1,2,2,2,3,2,1,2,2,2,1,2,1,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,1,2,2,1,2,1,2,2,3,2,2,2,1,2,2,3,3,2],
                        [2,3,2,1,2,2,2,1,1,1,3,1,1,1,2,1,2,2,2,3,1,2,1,1,2,2,2,3,1,1,1,1,1,1,1,1,3,2,2,2,2,2,2,1,1,3,2,2,2,2,2,2,2,2,3,1,2,1,1,2,1,1,2,3,2,2,1,1,2,2,2,3,5],
                        [2,3,2,2,2,2,1,1,1,2,3,2,1,1,2,1,2,1,2,3,1,1,1,1,2,1,2,3,2,2,1,1,1,1,2,1,3,4,2,2,2,2,1,1,2,3,2,2,2,2,2,2,2,2,3,1,2,1,1,2,1,1,2,3,2,2,1,2,2,2,2,3,2],
                        [2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2],
                        [2,3,2,2,2,2,2,1,2,1,3,2,1,2,1,2,1,1,2,3,2,2,2,2,2,2,2,3,2,1,2,1,1,1,1,1,3,2,2,2,2,2,1,1,2,3,4,1,1,2,1,1,1,1,3,1,2,2,2,2,1,2,2,3,2,2,2,1,1,1,1,3,2],
                        [2,3,2,2,2,2,2,1,2,2,3,1,1,2,1,1,1,1,2,3,2,2,1,1,1,2,2,3,1,1,2,1,1,1,1,2,3,2,2,2,2,2,1,1,1,3,1,1,1,1,1,1,1,1,3,1,2,2,2,2,1,2,2,3,2,2,2,2,1,2,2,3,2],
                        [2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5],
                        [2,3,2,2,2,1,2,2,2,2,3,1,2,1,2,2,2,2,2,3,2,2,2,2,2,2,1,3,2,1,1,1,1,1,2,2,3,2,1,2,2,2,2,1,2,3,2,1,2,2,2,1,1,2,3,2,2,1,2,2,2,1,2,3,2,1,1,2,2,2,2,3,2],
                        [2,3,1,1,1,1,2,1,2,2,3,1,1,1,2,2,2,2,2,3,2,2,2,2,2,2,1,3,2,1,1,1,2,1,1,1,3,1,1,2,2,1,2,1,2,3,1,1,2,1,1,1,1,2,3,1,2,1,1,2,1,1,2,3,2,2,1,2,1,1,2,3,2],
                        [2,3,1,2,2,2,1,1,1,2,3,1,1,1,2,1,2,2,2,3,2,2,2,2,2,2,1,3,2,2,1,1,2,1,1,2,3,2,1,2,2,1,2,1,2,3,2,1,2,1,2,1,1,2,3,2,2,1,1,2,1,2,2,3,1,1,1,2,1,1,2,3,2],
                        [2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5],
                        [2,3,2,2,2,2,2,1,1,2,3,1,2,2,1,1,2,1,2,3,1,2,1,1,3,1,2,3,2,2,1,1,1,1,1,1,3,2,2,1,2,1,1,2,1,3,1,1,1,1,1,1,1,2,3,1,1,1,1,1,2,1,1,3,2,1,1,2,1,2,2,3,5],
                        [2,3,2,2,2,2,2,1,1,2,3,1,2,2,1,1,2,1,2,3,1,2,2,2,3,1,1,3,2,1,1,1,2,1,1,1,3,4,2,1,2,1,1,2,1,3,1,1,1,1,1,2,1,1,3,1,1,1,1,1,2,1,4,3,1,1,1,2,1,1,1,3,2],
                        [2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2],
                        [2,3,2,1,2,2,2,2,2,2,3,2,1,2,2,1,2,2,2,3,2,2,2,4,3,2,1,3,2,2,1,2,2,2,2,2,3,2,2,1,1,1,2,2,2,3,2,2,2,1,1,2,4,2,3,2,2,2,2,2,1,2,2,3,2,1,1,2,1,1,2,3,2],
                        [2,3,2,1,2,2,2,2,2,2,3,2,1,2,2,1,2,2,2,3,2,2,1,2,3,2,1,3,2,1,1,2,2,2,2,2,3,1,1,1,1,1,1,2,1,3,1,2,2,1,1,1,1,1,3,1,2,1,2,2,1,2,2,3,2,1,1,1,1,1,2,3,2],
                        [2,3,2,1,2,2,2,2,2,2,3,2,1,2,2,1,2,2,2,3,2,2,1,2,3,2,2,3,2,1,1,2,2,1,2,2,3,2,1,1,1,1,1,2,1,3,1,1,1,1,1,2,1,2,3,1,2,1,2,2,1,2,2,3,2,1,1,2,1,1,2,3,2],
                        [4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,1,1,2,1,1,2,3,2,1,1,2,1,1,1,3,2,2,1,1,2,1,1,2,3,1,1,1,2,1,1,1,1,3,1,1,1,1,2,2,2,2,3,2,1,2,1,1,1,2,2,3,1,1,2,1,1,1,1,3,2],
                        [2,3,1,1,1,1,1,1,1,4,3,2,2,1,1,1,1,1,1,3,2,1,2,1,1,2,1,3,2,2,2,2,2,2,1,1,3,2,1,1,2,1,1,1,1,3,2,2,2,1,2,2,2,2,3,2,1,2,1,2,2,2,2,3,2,1,2,1,1,2,2,3,5],
                        [5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,4,3,2,2,1,3,2,2,2,2,2,2,2,2,3,2,2,2,1,2,1,2,2,3,2,2,1,2,2,2,2,2,3,2,2,1,2,2,2,1,1,3,2,2,2,2,1,2,2,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,2,2,2,2,2,2,2,2,3,2,2,1,3,2,1,1,3,1,1,2,1,1,2,2,1,3,2,2,2,1,2,1,2,1,3,2,2,1,1,1,2,2,2,3,1,2,1,2,2,1,1,2,3,2,2,2,2,1,1,4,3,2],
                        [2,3,2,2,2,2,2,2,2,2,3,1,2,2,2,2,2,2,2,3,2,2,1,3,1,1,1,3,2,1,2,1,2,2,1,1,3,2,2,2,1,1,1,2,1,3,2,2,1,1,1,2,1,2,3,2,2,1,2,2,2,1,2,3,2,2,2,2,2,1,2,3,2],
                        [2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2],
                        [2,3,2,2,1,2,2,1,1,2,3,1,1,2,2,1,2,2,2,3,2,2,1,3,2,1,2,3,2,1,2,2,1,2,1,1,3,2,1,1,1,1,1,1,2,3,2,2,1,2,1,1,1,2,3,1,2,1,1,1,1,1,2,3,1,1,1,1,1,1,2,3,2],
                        [2,3,2,2,1,2,2,1,1,1,3,1,1,2,2,1,2,2,2,3,2,2,1,3,2,1,2,3,2,1,2,2,2,2,2,1,3,2,1,2,1,1,2,1,2,3,2,2,1,2,2,1,1,2,3,1,2,1,2,2,2,1,1,3,2,2,2,1,2,2,1,3,2],
                        [2,3,2,2,1,2,2,1,2,2,3,2,1,2,2,1,2,2,2,3,2,2,1,3,2,1,2,3,2,1,2,2,2,2,2,1,3,2,1,2,1,1,2,1,2,3,4,2,1,2,2,1,1,2,3,1,2,1,2,2,2,1,1,3,2,2,2,1,2,2,1,3,2],
                        [5,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,5],
                        [2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,2,2,2,2,5,2,2,2,2,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,4,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,5,2,2,2,2,5,2,2,2,2]
                    ];

            // Calculating board size based on the tilemap
            var tileNbX = map[0].length;
            var tileNbY = map.length;
            var PLAYGROUND_WIDTH    = tileNbX * tileW;
            var PLAYGROUND_HEIGHT   = tileNbY * tileH;


            var pacman=[];
            // Let the game begin!
            pacman["idle"] = new $.gameQuery.Animation({
                imageURL: "images/pm-idle.png"
            });

            pacman["walking"] = new $.gameQuery.Animation({
                imageURL: "images/pm-down.png",
                numberOfFrame: 9,
                delta: 27,
                rate: 50,
                type: $.gameQuery.ANIMATION_HORIZONTAL
            });

            pacman["hit"] = new $.gameQuery.Animation({
                imageURL: "images/pm-hit.png",
                numberOfFrame: 7,
                delta: 26,
                rate: 200,
                type: $.gameQuery.ANIMATION_HORIZONTAL | $.gameQuery.ANIMATION_ONCE
            });

            // My own wall collision detection function
            var collisionDetect = function(x,y,animationCode){
                var cellx = Math.round(((x+PLAYGROUND_WIDTH/2)*tileNbX)/PLAYGROUND_WIDTH)-1;
                var celly = Math.round(((y+PLAYGROUND_HEIGHT/2)*tileNbY)/PLAYGROUND_HEIGHT);
                // Mapping x and y to a map tile
                console.log("Collision detection with ("+cellx+","+celly+"):"+(map[celly][cellx] == animationCode));
                return map[celly][cellx] == animationCode;
            };

            //
            var plotXFromTile = function(colX){
                var pixel_x = (parseInt(colX)+1)*tileW;
                return pixel_x;
            }

            var plotYFromTile = function(rowY){
                var pixel_y = (parseInt(rowY)+1)*tileH+2;
                return pixel_y;
            }

            // Pointers to current date / time markers
            var currentDateDisplay = $('#currentDate');
            currentDateDisplay.html("...");
            var currentTimeDisplay = $('#currentTime');
            currentTimeDisplay.html("...");

            var dt;
            var displayTime = function(offsetInMn){
                if (!dt)
                {
                    var fts = ghostRoutes[0].s;
                    dt = new Date(fts.substring(0,4),fts.substring(5,7),fts.substring(8,10),fts.substring(11,13),fts.substring(14,16),fts.substring(17,19));
                }
                // Applying the offset (needs to be an integer - should we cater for decimal minutes i.e. seconds? yes)
                dt.setMinutes(dt.getMinutes()+offsetInMn);

                // Displaying it
                var minutesStr = dt.getMinutes();
                if (minutesStr<10){minutesStr = "0"+minutesStr;}
                var hoursStr = dt.getHours();
                if (hoursStr<10){hoursStr = "0"+hoursStr;}

                currentDateDisplay.html(dt.getDate()+"/"+dt.getMonth()+1+"/"+dt.getFullYear());
                currentTimeDisplay.html(hoursStr+":"+minutesStr);
            }

            var currentGhostNb = 0;
            var currentGhostNbDisplay = $('#currentGhostNb');            
            var displayGhostsInPlay = function(nb){
                currentGhostNb += nb; 
                currentGhostNbDisplay.html(currentGhostNb); 
            }

            // Configuring the playground
            $('#playground').playground({
                    height: PLAYGROUND_HEIGHT, 
                    width: PLAYGROUND_WIDTH, 
                    keyTracker: true
                })
                .addTilemap("tilemap", map,  animations, {
                    width: tileW, 
                    height: tileH, 
                    sizex: tileNbX, 
                    sizey: tileNbY
                }).end()
                .addGroup("bikestations", {
                    width: PLAYGROUND_WIDTH, 
                    height: PLAYGROUND_HEIGHT
                }).end()
                .addGroup("pacgums", {
                    width: PLAYGROUND_WIDTH, 
                    height: PLAYGROUND_HEIGHT
                }).end()
                .addGroup("player",{
                    width: playerW, 
                    height: playerH
                }).end()
                .addGroup("ghosts",{
                    width: playerW, 
                    height: playerH
                }).end()
                // Centering the playground
                .css({"position":"relative","margin":"0 auto"})
                ;

            
            // configure the loading bar
            $.loadCallback(function(percent){
                $("#loadBar").width(400*percent);
                $("#loadtext").html(""+percent+"%")
            });
            
            // register the start button and remove the splash screen once the game is ready to starts
            $("#start").click(function(){
                // Game initialisation routine
                var gameInit = function(){
                    $("#splash").remove();

                    // Display the time
                    var firstOffsetMn = parseInt(ghostRoutes[0].o);
                    displayTime(-firstOffsetMn);

                    $("#player").addSprite("pacman", {
                        animation: pacman["idle"],
                        posx: 0,
                        posy: 0,
                        width: playerW, 
                        height: playerH
                    });

                    pacmanElt = $("#pacman");

                    ghostAnimArr = {
                        "green": new $.gameQuery.Animation({imageURL: "images/ghost-small-green.png"}),
                        "orange": new $.gameQuery.Animation({imageURL: "images/ghost-small-orange.png"}),
                        "red": new $.gameQuery.Animation({imageURL: "images/ghost-small-red.png"})
                    };

                    // Positionning the pacgums
                    var pacgumArr = {
                        "apple": {
                            "animation":new $.gameQuery.Animation({imageURL: "images/apple-small.png"}),
                            "width": 20,
                            "height": 20,
                            "pts": 10
                        },
                        "banana": {
                            "animation":new $.gameQuery.Animation({imageURL: "images/banana-small.png"}),
                            "width": 25,
                            "height": 16,
                            "pts": 10
                        },
                        "cherry": {
                            "animation":new $.gameQuery.Animation({imageURL: "images/cherry-small.png"}),
                            "width": 22,
                            "height": 22,
                            "pts": 10
                        },
                        "coffee": {
                            "animation":new $.gameQuery.Animation({imageURL: "images/coffeecup-small.png"}),
                            "width": 25,
                            "height": 24,
                            "pts": 10
                        },
                        "strawberry": {
                            "animation":new $.gameQuery.Animation({imageURL: "images/strawberry-small.png"}),
                            "width": 16,
                            "height": 24,
                            "pts": 10
                        },
                        "watermelon": {
                            "animation":new $.gameQuery.Animation({imageURL: "images/watermelon-small.png"}),
                            "width": 26,
                            "height": 21,
                            "pts": 10
                        }
                    };

                    var pacgum;

                    for (var j=0; j < tileNbY ; j+=1)
                    {
                        for (var i=0; i < tileNbX ; i+=1)
                        {
                            if (map[j][i] == 3 && ((i+j)%8==0))
                            {
                                var r = Math.random();
                                if (r<0.5)
                                {
                                    pacgum = pacgumArr["cherry"];
                                }
                                else if (r<0.7)
                                {
                                    pacgum = pacgumArr["strawberry"];
                                }
                                else if (r<0.8)
                                {
                                    pacgum = pacgumArr["banana"];
                                }
                                else if (r<0.9)
                                {
                                    pacgum = pacgumArr["watermelon"];
                                }
                                else if (r<=1.0)
                                {
                                    pacgum = pacgumArr["coffee"];
                                }

                                // Width and height must be those of the image
                                // Pox and posy must reflect the image size as well
                                $("#pacgums").addSprite("pg-"+i+"_"+j+"X"+pacgum.pts, {
                                    animation: pacgum.animation,
                                    posx: (i+1/2)*tileW-pacgum.width/2, 
                                    posy: (j+1/2)*tileH-pacgum.height/2,
                                    width: pacgum.width,
                                    height: pacgum.height
                                });

                            }
                        }
                    }

                    $("#player")[0].player = new Player($("#player"));
                    player = $("#player");

                };
                
                var releaseGhosts = function(currentTimer){
                    if (lastGhostIdx >= ghostRoutes.length)
                    {
                        alert("All ghosts have been released!");
                    }

                    // Releasing the ghosts
                    for (var j=lastGhostIdx;j<Object.keys(ghostRoutes).length;j++)
                    {
                        if (parseInt(ghostRoutes[j].o) < currentTimer)
                        {
                            // Duration of trips: short / medium / long
                            var tripDuration = parseInt(ghostRoutes[j].d);

                            if (tripDuration < 20)
                            {ghost = ghostAnimArr["green"];}
                            else if (tripDuration < 40)
                            {ghost = ghostAnimArr["orange"];}
                            else
                            {ghost = ghostAnimArr["red"];}

                            // Release the ghost!
                            $("#ghosts").addSprite("ghost"+j, {
                                animation: ghost,
                                posx: 0, 
                                posy: 0,
                                width: playerW, 
                                height: playerH
                            });

                            $("#ghost"+j)[0].ghost = new Ghost($("#ghost"+j),ghostRoutes[j+""].l.split(","));
                            allGhosts[j] = $("#ghost"+j)[0].ghost;

                            // Incrementing the last released ghist index
                            lastGhostIdx++;
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                // Loading the asset file where the ghosts routes are
                $.getJSON("routed_events/assets.json",
                    {},
                    function(json){
                        //
                        if (json)
                        {
                            // Now moving to the detail page with this task id
                            console.log('Asset JSON file loaded: ' + Object.keys(json).length + ' events.');
                            // Global variable holding the routes
                            ghostRoutes = json;
                            // Game init routine
                            $.playground().startGame(gameInit);
                        }
                    }
                );

                function Player(node){
                    var that = this;
                    this.node = node;
                    this.respawnTime = -1;
                    this.grace = false;
                    this.score = 0;
                    this.lock = false;
                    this.dead = false;

                    // Initial position - somewhere in the middle of the grid
                    this.node.x(PLAYGROUND_WIDTH/2-(PLAYGROUND_WIDTH/2%tileW)+tileW/2-playerW/2);
                    this.node.y(PLAYGROUND_HEIGHT/2-(PLAYGROUND_HEIGHT/2%tileH)+tileH/2-playerH/2);

                    this.addPoints=function(pts){
                        this.score += pts;
                        $('#currentScore').html(this.score);
                    };

                    this.resetScore=function(pts){
                        // Should we be saving hi-scores in there?
                        this.score = 0;
                        $('#currentScore').html(this.score);
                    };                    

                    this.hit = function(){
                        //
                        this.resetScore();
                        this.dead = true;
                        pacmanElt.setAnimation(pacman["hit"]);
                        previousMove = "stop";
                        setTimeout(function(){
                            pacmanElt.setAnimation(pacman["idle"]);
                            that.dead = false;
                            that.lock = false;
                        }, 2500);
                    }

                    this.moveTo = function(newx,newy){
                        //console.log('Moving from:'+this.node.x()+','+this.node.y()+' to '+newx+','+newy);

                        if(newx >= 0 && newx <= PLAYGROUND_WIDTH && newx != this.node.x()){
                            if (player.collision('#tilemap,#tilemap div.gQ_tileType_2',{x:newx}).length)
                            {
                                //console.log('Moving to tile:'+$('#player').collision('#tilemap,#tilemap div.gQ_tileType_2',{x:newx})[0].id+' ('+$('#player').collision('#tilemap,#tilemap div',{x:newx}).length+' tiles detected)');

                                this.lock = true;
                                this.node.animate({x:newx}, 
                                    {
                                        duration:STEP_SPEEDX, 
                                        complete:function(){
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.x(newx);
                                        }
                                    }
                                );
                            }
                            else
                            {
                                player[0].player.lock = false;
                                //console.log('Can\'t move right/left due to tile:'+$('#pacman').collision('#tilemap,#tilemap div.gQ_tileType_1',{x:newx})[0].id);
                            }
                        }
                        else if (newy >= 0 && newy <= PLAYGROUND_HEIGHT && newy != this.node.y()){
                            if (player.collision('#tilemap,#tilemap div.gQ_tileType_2',{y:newy}).length)
                            {
                                //console.log('Moving to tile:'+$('#player').collision('#tilemap,#tilemap div.gQ_tileType_2',{y:newy})[0].id+' ('+$('#player').collision('#tilemap,#tilemap div',{y:newy}).length+' tiles detected)');

                                this.lock = true;
                                this.node.animate({y:newy}, 
                                    {
                                        duration:STEP_SPEEDY, 
                                        complete:function(){
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.y(newy);
                                        }
                                    }
                                );
                            }
                            else
                            {
                                player[0].player.lock = false;
                                //console.log('Can\'t move up/down due to tile:'+$('#player').collision('#tilemap,#tilemap div.gQ_tileType_1',{y:newy})[0].id);
                            }
                        }
                    }

                    return true;
                }

                function Ghost(node,route,duration){
                    var that = this;
                    this.node = node;
                    this.route = route;
                    this.lock = false;

                    // Initial position
                    this.node.css("opacity",0);
                    this.node.x(plotXFromTile(parseInt(this.route[0].split("X")[0])));
                    this.node.y(plotYFromTile(parseInt(this.route[0].split("X")[1])));
                    this.node.animate({opacity:1},GHOST_OPACITY_TRANSITION_MS,function(){
                        displayGhostsInPlay(1);
                    });
                    // Removing the position we just consumed
                    this.route.shift();

                    // updates the position of the enemy
                    this.updateOne = function(playerNode){
                        if (this.route.length && !this.lock)
                        {
                            this.lock = true;
                            this.updateX(playerNode);
                            this.updateY(playerNode);
                        }

                        // If we arrived at the end of the route, we need to destroy the ghost and remove it from the ghost array
                        if (!this.route.length)
                        {
                            // The animation does not portray where the ghost really disappears
                            this.node.animate({opacity:0},GHOST_OPACITY_TRANSITION_MS,function(){
                                // We wanted to get this counter before the animation callback but that just won't work
                                displayGhostsInPlay(-1);

                                var ghostIdx = allGhosts.indexOf(that);
                                if (ghostIdx>-1)
                                {
                                    allGhosts.splice(ghostIdx,1);
                                }

                                // Removing the sprite from the DOM / gQ group
                                that.node.remove();
                            });
                        }
                    };    
                      
                    this.updateX = function(playerNode){
                        var nextposx = plotXFromTile(parseInt(this.route[0].split("X")[0]));
                        if (nextposx != this.node.x())
                        {
                            this.node.animate({x:nextposx}, 
                                {
                                    duration:GHOST_STEP_SPEEDX+(Math.random()*0.5-0.25)*GHOST_STEP_SPEEDX, 
                                    complete:function(){
                                        if (that.lock)
                                        {
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.x(nextposx);
                                            // Removing the position that's just been the object of the update
                                            that.route.shift();                                            
                                        }
                                    }
                                }
                            );
                        }
                    };
                    this.updateY= function(playerNode){
                        var nextposy = plotYFromTile(parseInt(this.route[0].split("X")[1]));
                        if (nextposy != this.node.y())
                        {
                            this.node.animate({y:nextposy}, 
                                {
                                    duration:GHOST_STEP_SPEEDY+(Math.random()*0.5-0.25)*GHOST_STEP_SPEEDY, 
                                    complete:function(){
                                        if (that.lock)
                                        {
                                            that.lock = false;
                                            // Actually move to the new position
                                            // Critical for collision detections!
                                            that.node.y(nextposy);                                        
                                            // Removing the position that's just been the object of the update
                                            that.route.shift();                                            
                                        }
                                    }
                                }
                            );
                        }
                    };

                    return true;
                }

                $.playground().registerCallback(function(){
                    timer += SIMULATED_TIME_RATE;
                    releaseGhosts(timer);
                    displayTime(SIMULATED_TIME_RATE);

                    if (!player[0].player.dead)
                    {

                        var pacgumCollision = player.collision("#pacgums,#pacgums div");
                        if (pacgumCollision.length)
                        {
                            pacgumCollision.each(function(idx,pacgum){
                                //console.log("Collided with pacgum"+pacgum.id);
                                $('#'+pacgum.id).animate({opacity:0},100);
                                $('#'+pacgum.id).remove();

                                var ptsToAdd = parseInt(pacgum.id.split("X")[1]);
                                // Updating the score as well
                                player[0].player.addPoints(ptsToAdd);
                            });
                        }

                        var ghostCollision = player.collision("#ghosts,#ghosts div");
                        if (ghostCollision.length)
                        {
                            ghostCollision.each(function(idx,ghost){
                                console.log("Ghost "+ghost.id+" has collided with Pacman!")
                                player[0].player.hit();
                            });
                        }

                        // Continuing to walk if move hasn't been stopped
                        if (previousMove != "stop")
                        {
                            //Update the movement of the player
                            if(!player[0].player.lock){
                                var posx = player[0].player.node.x();
                                var posy = player[0].player.node.y();
                                //$("#player")[0].player.update();
                                if(previousMove=="left"){ //this is left! (a)
                                    var nextpos = posx-SPEEDX;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(nextpos,posy);
                                }
                                if(previousMove=="right"){ //this is right! (d)
                                    var nextpos = posx+SPEEDX;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(nextpos,posy);
                                }
                                if(previousMove=="up"){ //this is up! (w)
                                    var nextpos = posy-SPEEDY;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(posx,nextpos);
                                }
                                if(previousMove=="down"){ //this is down! (s)
                                    var nextpos = posy+SPEEDY;
                                    player[0].player.lock = true;
                                    player[0].player.moveTo(posx,nextpos);
                                }
                            }
                        }

                    }


                    // Move the ghost
                    for (var j=0;j<allGhosts.length;j++)
                    {
                        if (allGhosts[j])
                        {
                            allGhosts[j].updateOne();
                        } 
                    }

                    }, REFRESH_RATE);
            });
        </script>
    </body>
</html>
